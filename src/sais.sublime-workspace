{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"macro",
				"macro	macro-def"
			],
			[
				"delete",
				"deleteat!"
			],
			[
				"dele",
				"deleteat!"
			],
			[
				"splic",
				"splice!"
			],
			[
				"searchsor",
				"searchsortedlast"
			],
			[
				"Fixed",
				"FixedWidthSlot"
			],
			[
				"ISODate",
				"ISODateFormat"
			],
			[
				"daysi",
				"daysinmonth"
			],
			[
				"millisecond",
				"Millisecond"
			],
			[
				"fuzzymat",
				"fuzzymatch"
			],
			[
				"bise",
				"bisect_right"
			],
			[
				"genes",
				"genes_file"
			],
			[
				"promote",
				"promote"
			],
			[
				"promot",
				"promote_rule"
			],
			[
				"decode",
				"decode_gamma2"
			],
			[
				"potent",
				"potential_backup"
			],
			[
				"devices",
				"devices_backed_up"
			],
			[
				"cod_",
				"code_llvm"
			],
			[
				"sort",
				"sort"
			],
			[
				"get",
				"get"
			],
			[
				"p_notin",
				"p_notinfected_pos"
			],
			[
				"search",
				"search"
			],
			[
				"fill",
				"fill!"
			],
			[
				"end",
				"end"
			],
			[
				"getindex",
				"getindex"
			],
			[
				"getind",
				"getindex"
			],
			[
				"shift",
				"shift!"
			],
			[
				"add",
				"add!"
			],
			[
				"readlin",
				"readlines"
			],
			[
				"trainmod",
				"trainmodel_entropy"
			],
			[
				"getoffset",
				"getoffsetsecond"
			],
			[
				"rand",
				"rand"
			],
			[
				"code",
				"code_llvm"
			],
			[
				"log",
				"log2"
			],
			[
				"lo",
				"log"
			],
			[
				"max",
				"maxintfloat"
			],
			[
				"Juli",
				"JULIANEPOCH"
			],
			[
				"ISOCAl",
				"ISOCalendarType"
			],
			[
				"tzdata",
				"tzdata2013h"
			],
			[
				"app",
				"append!"
			],
			[
				"generate",
				"generate_tzdata"
			],
			[
				"cod",
				"code_llvm"
			],
			[
				"RMOn",
				"RMONTHSABR"
			],
			[
				"DAYS",
				"DAYSOFWEEK"
			],
			[
				"DatetimeRang",
				"DatetimeRange1"
			],
			[
				"searchsort",
				"searchsortedfirst"
			],
			[
				"sea",
				"searchsortedfirst"
			],
			[
				"_leap",
				"_leapmoments1"
			],
			[
				"ceil",
				"iceil"
			],
			[
				"_leapmom",
				"_leapmoments"
			],
			[
				"findfir",
				"findfirst"
			],
			[
				"Calen",
				"CALENDAR"
			],
			[
				"esc",
				"escape_string"
			],
			[
				"C",
				"CALENDAR"
			],
			[
				"typm",
				"typemax"
			],
			[
				"d",
				"deconv"
			],
			[
				"csv",
				"writecsv"
			],
			[
				"PATH",
				"LOAD_PATH"
			],
			[
				"radian",
				"degrees2radians"
			],
			[
				"lco",
				"loc_bldg"
			],
			[
				"loc",
				"loc_bldg"
			],
			[
				"copy",
				"copy!"
			],
			[
				"edit",
				"edit_chunk"
			],
			[
				"edi",
				"edit_chunk"
			],
			[
				"text",
				"text_transfer"
			],
			[
				"user",
				"user_input"
			],
			[
				"outpu",
				"output_change"
			],
			[
				"out",
				"output_change"
			],
			[
				"W",
				"WindowCommand"
			],
			[
				"sublime",
				"sublime_plugin"
			],
			[
				"julia",
				"julia_views"
			],
			[
				"kmar",
				"kmart_syw"
			],
			[
				"micro",
				"microseconds"
			],
			[
				"lci",
				"lci_work_tbls"
			],
			[
				"sales",
				"sales_tran_tbl"
			],
			[
				"ord",
				"ord_duns_nbr"
			],
			[
				"colu",
				"columnname"
			],
			[
				"M",
				"MemorialDay"
			],
			[
				"_l",
				"_leapmoments1"
			],
			[
				"l",
				"leaps1"
			],
			[
				"use",
				"useleapseconds"
			],
			[
				"Date",
				"DateExtensions"
			],
			[
				"dayof",
				"dayofweekinmonth"
			],
			[
				"DateTim",
				"DateTimeDate"
			],
			[
				"Time",
				"TimeType"
			],
			[
				"Zone",
				"Zone382DATA"
			],
			[
				"counter",
				"counterstart"
			],
			[
				"TIM",
				"TIMEZONE"
			],
			[
				"vecto",
				"vectorize_2arg"
			],
			[
				"dollar",
				"dollar_sales"
			],
			[
				"promo",
				"promote_rule"
			],
			[
				"ISO",
				"ISOCalendar"
			],
			[
				"q",
				"q_all_ce"
			],
			[
				"_day",
				"_daynumbers"
			],
			[
				"Cal",
				"Calendar"
			],
			[
				"mon",
				"MONTHOFFSETS"
			],
			[
				"IsoC",
				"ISOCalendar"
			],
			[
				"baske",
				"basket_uid2"
			],
			[
				"corp",
				"corp_date"
			],
			[
				"null",
				"null_SqliteDB"
			],
			[
				"syw",
				"sears_syw"
			],
			[
				"sqlite3_prep",
				"sqlite3_prepare_v2"
			],
			[
				"sqlite3_op",
				"sqllite3_open"
			],
			[
				"SQL_LONGVAR",
				"SQL_LONGVARBINARY"
			],
			[
				"fisc",
				"fisc_year"
			],
			[
				"format",
				"format_sub_type"
			],
			[
				"lcixt",
				"lcixtfs_fty_sbt"
			],
			[
				"new",
				"new_number"
			],
			[
				"cow",
				"cowsbulls"
			],
			[
				"roll",
				"rolling_12_reason_code"
			],
			[
				"month",
				"month_lit"
			],
			[
				"cus",
				"cus_ian_id_no"
			],
			[
				"basket",
				"basket_uid"
			],
			[
				"week",
				"week10"
			],
			[
				"on",
				"onload"
			],
			[
				"print",
				"print_table"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "#=\n * sais\n * Copyright (c) 2008-2010 Yuta Mori All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n =#\n\n#= Suffixsorting =#\n# byte\ntype ByteArray\n    a::Array{Uint8,1}\n    pos::Int\nend\ngetindex(a::ByteArray,key) = a.a[key]\nsetindex!(a::ByteArray,value,key) = a.a[key] = value\n\ntype IntArray\n    a::Array{Int,1}\n    pos::Int\nend\ngetindex(a::IntArray,key) = a.a[key]\nsetindex!(a::IntArray,value,key) = a.a[key] = value\n\nfunction suffixsort(T::Array{Uint8,1},SA::Array{Int,1},n::Int)\n    if isempty(T) || isempty(SA) || length(T) < n || length(SA) < n\n        return -1\n    end\n    if n <= 1\n        n == 1 && (SA[1] = 0)\n        return 0\n    end\n    return SA_IS(ByteArray(T,0), SA, 0, n, 256, false)\nend\n\nfunction SA_IS(T, SA, fs, n, k, isbwt)\n    pidx = 0\n    flags = 0\n    if k <= 256\n        C = IntArray(zeros(Int,k),0)\n        if k <= fs\n            B = IntArray(SA,n + fs - k)\n            flags = 1\n        else\n            B = IntArray(zeros(Int,k),0)\n            flags = 3\n        end\n    elseif k <= fs\n        C = IntArray(SA,n + fs - k)\n        if k <= fs - k\n            B = IntArray(SA,n + fs - 2k)\n            flags = 0\n        elseif k <= 1024\n            B = IntArray(zeros(Int,k),0)\n            flags = 2\n        else\n            B = C\n            flags = 8\n        end\n    else\n        C = B = IntArray(zeros(Int,k),0)\n        flags = 4 | 8\n    end\n    # stage 1\n    # C is zeroed out, then for each character (byte) of T\n    # it's value is used as the index in C and is incremented by 1\n    getcounts(T,C,n,k)\n    # B keeps running total from 1:k of how many characters have\n    # been seen up to that byte value. The last boolean\n    # argument decrements somehow?\n    getbuckets(C,B,k,true)\n    for i = 1:n\n        SA[i] = 0\n    end\n    b = 0 # was -1\n    i = n\n    j = n + 1 # was just n\n    m = 0\n    c0 = c1 = T[n]\n    while true\n        c1 = c0\n        i -= 1\n        c0 = T[i]\n        1 > i || c0 < c1 && break\n    end\n    while 1 <= i\n        while true\n            c1 = c0\n            i -= 1\n            c0 = T[i]\n            1 > i || c0 > c1 && break\n        end\n        if 1 <= i\n            1 <= b && (SA[b] = j)\n            b = (B[c1] -= 1) + 1\n            j = i\n            m += 1\n            while true\n                c1 = c0\n                i -= 1\n                c0 = T[i]\n                0 > i || c0 < c1 && break\n            end\n        end\n    end\n    if 1 < m\n        LMSsort(T,SA,C,B,n,k)\n        name = LMSpostproc(T,SA,n,m)\n    elseif m == 1\n        SA[b] = j\n        name = 1\n    else\n        name = 0\n    end\n    # stage 2\n    if name < m\n        if flags & 4 != 0\n            C = B = nothing\n        end\n        if flags & 2 != 0\n            B = nothing\n        end\n        newfs = (n + fs) - (m * 2)\n        if flags & (1 | 4 | 8) == 0\n            if (k + name) <= newfs\n                newfs -= k\n            else\n                flags |= 8\n            end\n        end\n        j = 2m + newfs\n        for i = (m + (n >> 1)):-1:(m-1)\n            if SA[i] != 0\n                SA[j] = SA[i] - 1\n                j -= 1\n            end\n        end\n        RA = IntArray(SA, m + newfs)\n        SA_IS(RA,SA,newfs,m,name,false)\n        #RA = nothing\n\n        i = n\n        j = 2m\n        c0 = T[n]\n        while true\n            c1 = c0\n            i -= 1\n            c0 = T[i]\n            1 > i || c0 < c1 && break\n        end\n        while 1 <= i\n            while true\n                c1 = c0\n                i -= 1\n                c0 = T[i]\n                1 > i || c0 > c1 && break\n            end\n            if 1 <= i\n                SA[j] = i + 1\n                j -= 1\n                while true\n                    c1 = c0\n                    i -= 1\n                    c0 = T[i]\n                    0 > i || c0 < c1 && break\n                end\n            end\n        end\n        for i = 1:m\n            SA[i] = SA[m+SA[i]+1]\n        end\n        if flags & 4 != 0\n            C = B = IntArray(zeros(Int,k),0)\n        end\n        if flags & 2 != 0\n            B = IntArray(zeros(Int,k),0)\n        end\n    end\n    # stage 3\n    flags & 8 != 0 && getcounts(T,C,n,k)\n    if 1 < m\n        getbuckets(C,B,k,true)\n        i = m\n        j = n + 1\n        p = SA[m]\n        c1 = T[p] # p + 1?\n        while true\n            co = c1\n            q = B[c0]\n            while q < j\n                j -= 1\n                SA[j] = 0\n            end\n            while true\n                j -= 1\n                SA[j] = p\n                i -= 1\n                i < 1 && break\n                p = SA[i]\n                c1 = T[p]\n                c1 != c0 && break\n            end\n            1 > i && break\n        end\n        while 1 < j\n            j -= 1\n            SA[j] = 0\n        end\n    end\n    if isbwt == false\n        induceSA(T,SA,C,B,n,k)\n    else\n        pidx = computeBWT(T,SA,C,B,n,k)\n    end\n    return pidx\nend\n\nfunction getcounts(T,C,n,k)\n    for i = 1:k\n        C[i] = 0\n    end\n    for i = 1:n\n        C[T[i]] += 1\n    end\nend\n\nfunction getbuckets(C,B,k,is_end)\n    sum = 0\n    if is_end\n        for i = 1:k\n            sum += C[i]\n            B[i] = sum\n        end\n    else\n        for i = 1:k\n            sum += C[i]\n            B[i] = sum - C[i]\n        end\n    end\nend\n\nfunction LMSsort(T, SA, C, B, n, k)\n    C == B && getcounts(T,C,n,k)\n    getbuckets(C,B,k,false)\n    j = n - 1\n    c1 = T[j]\n    b = B[c1]\n    j -= 1\n    SA[b] = T[j] < c1 ? ~j : j\n    b += 1\n    for i = 1:n\n        j = SA[i]\n        if 0 < j\n            c0 = T[j]\n            if c0 != c1\n                B[c1] = b\n                c1 = c0\n                b = B[c1]\n            end\n            j -= 1\n            SA[b] = T[j] < c1 ? ~j : j\n            b += 1\n            SA[i] = 0\n        elseif j < 0\n            SA[i] = ~j\n        end\n    end\n    C == B && getcounts(T,C,n,k)\n    getbuckets(C,B,k,true)\n    c1 = 0\n    b = B[c1] #fix\n    for i = n:-1:1\n        j = SA[i]\n        if 0 < j\n            c0 = T[j]\n            if c0 != c1\n                B[c1] = b\n                c1 = c0\n                b = B[c1]\n            end\n            j -= 1\n            b -= 1\n            SA[b] = T[j] < c1 ? ~(j+1) : j\n            SA[i] = 0\n        end\n    end\nend\n\nfunction LMSpostproc(T,SA,n,m)\n    i = 1\n    p = SA[i]\n    while p < 0\n        SA[i] = ~p\n        i += 1 # maybe goes above?\n    end\n    if i < m\n        j = i\n        i += 1\n        while true\n            p = SA[i]\n            if p < 0\n                SA[j] = ~p\n                j += 1\n                SA[i] = 0\n                j == m && break\n            end\n        end\n    end\n\n    i = n - 1\n    j = n - 1\n    c0 = T[n-1]\n    while true\n        c1 = c0\n        i -= 1\n        c0 = T[i]\n        0 > i || c0 < c1 && break\n    end\n    while 0 <= i\n        while true\n            c1 = c0\n            i -= 1\n            c0 = T[i]\n            0 > i || c0 < c1 && break\n        end\n        if 0 <= i\n            SA[m + ((i+1) >> 1)] = j - i\n            j = i + 1\n            while true\n                c1 = c0\n                i -= 1\n                c0 = T[i]\n                0 > i || c0 < c1 && break\n            end\n        end\n    end\n    name = 0\n    q = n\n    qlen = 0\n    for i = 1:m\n        p = SA[i]\n        plen = SA[m + (p >> 1)]\n        diff = true\n        if plen == qlen && (q + plen < n)\n            j = 0\n            while j < plen && T[p+j] == T[q+j]\n                j += 1\n            end\n            j == plen && (diff = false)\n        end\n        if diff != false\n            name += 1\n            q = p\n            qlen = plen\n        end\n        SA[m + (p >> 1)] = name\n    end\n    return name\nend\n\nfunction induceSA(T,SA,C,B,n,k)\n    C == B && getcounts(T,C,n,k)\n    getbuckets(C,B,k,false)\n    j = n - 1\n    c1 = T[j]\n    b = B[c1]\n    SA[b] = 0 < j && T[j-1] < c1 ? ~j : j\n    b += 1\n    for i = 1:n\n        j = SA[i]\n        SA[i] = ~j\n        if 0 < j\n            j -= 1\n            c0 = T[j]\n            if c0 != c1\n                B[c1] = b\n                c1 = c0\n                b = B[c1]\n            end\n            SA[b] = 0 < j && T[j-1] < c1 ? ~j : j\n            b += 1\n        end\n    end\n    C == B && getcounts(T,C,n,k)\n    getbuckets(C,B,k,true)\n    for i = n:-1:1\n        j = SA[i]\n        if 0 < j\n            j -= 1\n            c0 = T[j]\n            if c0 != c1\n                B[c1] = b\n                c1 = c0\n                b = B[c1]\n            end\n            b -= 1\n            SA[b] = j == 0 || T[j-1] > c1 ? ~j : j\n        else\n            SA[i] = ~j\n        end\n    end\nend\n\nfunction computeBWT(T,SA,C,B,n,k)\n    pidx = -1\n    C == B && getcounts(T,C,n,k)\n    getbuckets(C,B,k,false)\n    j = n-1\n    c1 = T[j]\n    b = B[c1]\n    SA[b] = 0 < j && T[j-1] < c1 ? ~j : j\n    b += 1\n    for i = 1:n\n        j = SA[i]\n        if 0 < j\n            j -= a\n            c0 = T[j]\n            SA[i] = ~(c0)\n            if c0 != c1\n                B[c1] = b\n                c1 = c0\n                b = B[c1]\n            end\n            SA[b] = 0 < j && T[j-1] < c1 ? ~j : j\n            b += 1\n        elseif j != 0\n            SA[i] = ~j\n        end\n    end\n    C == B && getcounts(T,C,n,k)\n    getbuckets(C,B,k,true)\n    for i = n:-1:1\n        j = SA[i]\n        if 0 < j\n            j -= 1\n            c0 = T[j]\n            SA[i] = c0\n            if c0 != c1\n                B[c1] = b\n                c1 = c0\n                b = B[c1]\n            end\n            b -= 1\n            SA[b] = 0 < j && T[j-1] > c1 ? ~(T[j-1]) : j\n        elseif j != 0\n            SA[i] = ~j\n        else\n            pidx = i\n        end\n    end\n    return pidx\nend\n",
			"file": "sais.jl",
			"file_size": 10727,
			"file_write_time": 130507887976275745,
			"settings":
			{
				"buffer_size": 10621,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/karbarcca/code/sais-lite-2.4.1/sais-lite-2.4.1/sais.c",
			"settings":
			{
				"buffer_size": 16116,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n * sais.java for sais-java\n * Copyright (c) 2008-2010 Yuta Mori All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport java.lang.String;\n\npublic class sais {\n    private static interface BaseArray {\n        public int get(int i);\n        public void set(int i, int val);\n        public int update(int i, int val);\n    }\n    private static class ByteArray implements BaseArray {\n        private byte[] m_A = null;\n        private int m_pos = 0;\n        ByteArray(byte[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n        public int get(int i) {\n            return m_A[m_pos + i] & 0xff;\n        }\n        public void set(int i, int val) {\n            m_A[m_pos + i] = (byte)(val & 0xff);\n        }\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val & 0xff;\n        }\n    }\n    private static class CharArray implements BaseArray {\n        private char[] m_A = null;\n        private int m_pos = 0;\n        CharArray(char[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n        public int get(int i) {\n            return m_A[m_pos + i] & 0xffff;\n        }\n        public void set(int i, int val) {\n            m_A[m_pos + i] = (char)(val & 0xffff);\n        }\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val & 0xffff;\n        }\n    }\n    private static class ShortArray implements BaseArray {\n        private short[] m_A = null;\n        private int m_pos = 0;\n        ShortArray(short[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n        public int get(int i) {\n            return m_A[m_pos + i] & 0xffff;\n        }\n        public void set(int i, int val) {\n            m_A[m_pos + i] = (short)(val & 0xffff);\n        }\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val & 0xffff;\n        }\n    }\n    private static class IntArray implements BaseArray {\n        private int[] m_A = null;\n        private int m_pos = 0;\n        IntArray(int[] A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n        public int get(int i) {\n            return m_A[m_pos + i];\n        }\n        public void set(int i, int val) {\n            m_A[m_pos + i] = val;\n        }\n        public int update(int i, int val) {\n            return m_A[m_pos + i] += val;\n        }\n    }\n    private static class StringArray implements BaseArray {\n        private String m_A = null;\n        private int m_pos = 0;\n        StringArray(String A, int pos) {\n            m_A = A;\n            m_pos = pos;\n        }\n        public int get(int i) {\n            return (int)(m_A.charAt(m_pos + i) & 0xffff);\n        }\n        public void set(int i, int val) {}\n        public int update(int i, int val) {\n            return 0;\n        }\n    }\n\n    /* find the start or end of each bucket */\n    private static\n    void\n    getCounts(BaseArray T, BaseArray C, int n, int k) {\n        int i;\n        for (i = 0; i < k; ++i) {\n            C.set(i, 0);\n        }\n        for (i = 0; i < n; ++i) {\n            C.update(T.get(i), 1);\n        }\n    }\n    private static\n    void\n    getBuckets(BaseArray C, BaseArray B, int k, boolean end) {\n        int i, sum = 0;\n        if (end != false) {\n            for (i = 0; i < k; ++i) {\n                sum += C.get(i);\n                B.set(i, sum);\n            }\n        } else {\n            for (i = 0; i < k; ++i) {\n                sum += C.get(i);\n                B.set(i, sum - C.get(i));\n            }\n        }\n    }\n\n/* sort all type LMS suffixes */\nprivate static\nvoid\nLMSsort(BaseArray T, int[] SA, BaseArray C, BaseArray B, int n, int k) {\n    int b, i, j;\n    int c0, c1;\n    /* compute SAl */\n    if (C == B) {\n        getCounts(T, C, n, k);\n    }\n    getBuckets(C, B, k, false); /* find starts of buckets */\n    j = n - 1;\n    b = B.get(c1 = T.get(j));\n    --j;\n    SA[b++] = (T.get(j) < c1) ? ~j : j;\n    for (i = 0; i < n; ++i) {\n        if (0 < (j = SA[i])) {\n            if ((c0 = T.get(j)) != c1) {\n                B.set(c1, b);\n                b = B.get(c1 = c0);\n            }--j;\n            SA[b++] = (T.get(j) < c1) ? ~j : j;\n            SA[i] = 0;\n        } else if (j < 0) {\n            SA[i] = ~j;\n        }\n    }\n    /* compute SAs */\n    if (C == B) {\n        getCounts(T, C, n, k);\n    }\n    getBuckets(C, B, k, true); /* find ends of buckets */\n    for (i = n - 1, b = B.get(c1 = 0); 0 <= i; --i) {\n        if (0 < (j = SA[i])) {\n            if ((c0 = T.get(j)) != c1) {\n                B.set(c1, b);\n                b = B.get(c1 = c0);\n            }--j;\n            SA[--b] = (T.get(j) > c1) ? ~ (j + 1) : j;\n            SA[i] = 0;\n        }\n    }\n}\nprivate static\nint\nLMSpostproc(BaseArray T, int[] SA, int n, int m) {\n    int i, j, p, q, plen, qlen, name;\n    int c0, c1;\n    boolean diff;\n\n    /* compact all the sorted substrings into the first m items of SA\n    2*m must be not larger than n (proveable) */\n    for (i = 0;\n    (p = SA[i]) < 0; ++i) {\n        SA[i] = ~p;\n    }\n    if (i < m) {\n        for (j = i, ++i;; ++i) {\n            if ((p = SA[i]) < 0) {\n                SA[j++] = ~p;\n                SA[i] = 0;\n                if (j == m) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /* store the length of all substrings */\n    i = n - 1;\n    j = n - 1;\n    c0 = T.get(n - 1);\n    do {\n        c1 = c0;\n    } while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n    for (; 0 <= i;) {\n        do {\n            c1 = c0;\n        } while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n        if (0 <= i) {\n            SA[m + ((i + 1) >> 1)] = j - i;\n            j = i + 1;\n            do {\n                c1 = c0;\n            } while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n        }\n    }\n\n    /* find the lexicographic names of all substrings */\n    for (i = 0, name = 0, q = n, qlen = 0; i < m; ++i) {\n        p = SA[i];\n        plen = SA[m + (p >> 1)];\n        diff = true;\n        if ((plen == qlen) && ((q + plen) < n)) {\n            for (j = 0;\n            (j < plen) && (T.get(p + j) == T.get(q + j)); ++j) {}\n            if (j == plen) {\n                diff = false;\n            }\n        }\n        if (diff != false) {\n            ++name;\n            q = p;\n            qlen = plen;\n        }\n        SA[m + (p >> 1)] = name;\n    }\n\n    return name;\n}\n\n/* compute SA and BWT */\nprivate static\nvoid\ninduceSA(BaseArray T, int[] SA, BaseArray C, BaseArray B, int n, int k) {\n    int b, i, j;\n    int c0, c1;\n    /* compute SAl */\n    if (C == B) {\n        getCounts(T, C, n, k);\n    }\n    getBuckets(C, B, k, false); /* find starts of buckets */\n    j = n - 1;\n    b = B.get(c1 = T.get(j));\n    SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n    for (i = 0; i < n; ++i) {\n        j = SA[i];\n        SA[i] = ~j;\n        if (0 < j) {\n            if ((c0 = T.get(--j)) != c1) {\n                B.set(c1, b);\n                b = B.get(c1 = c0);\n            }\n            SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n        }\n    }\n    /* compute SAs */\n    if (C == B) {\n        getCounts(T, C, n, k);\n    }\n    getBuckets(C, B, k, true); /* find ends of buckets */\n    for (i = n - 1, b = B.get(c1 = 0); 0 <= i; --i) {\n        if (0 < (j = SA[i])) {\n            if ((c0 = T.get(--j)) != c1) {\n                B.set(c1, b);\n                b = B.get(c1 = c0);\n            }\n            SA[--b] = ((j == 0) || (T.get(j - 1) > c1)) ? ~j : j;\n        } else {\n            SA[i] = ~j;\n        }\n    }\n}\nprivate static\nint\ncomputeBWT(BaseArray T, int[] SA, BaseArray C, BaseArray B, int n, int k) {\n    int b, i, j, pidx = -1;\n    int c0, c1;\n    /* compute SAl */\n    if (C == B) {\n        getCounts(T, C, n, k);\n    }\n    getBuckets(C, B, k, false); /* find starts of buckets */\n    j = n - 1;\n    b = B.get(c1 = T.get(j));\n    SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n    for (i = 0; i < n; ++i) {\n        if (0 < (j = SA[i])) {\n            SA[i] = ~ (c0 = T.get(--j));\n            if (c0 != c1) {\n                B.set(c1, b);\n                b = B.get(c1 = c0);\n            }\n            SA[b++] = ((0 < j) && (T.get(j - 1) < c1)) ? ~j : j;\n        } else if (j != 0) {\n            SA[i] = ~j;\n        }\n    }\n    /* compute SAs */\n    if (C == B) {\n        getCounts(T, C, n, k);\n    }\n    getBuckets(C, B, k, true); /* find ends of buckets */\n    for (i = n - 1, b = B.get(c1 = 0); 0 <= i; --i) {\n        if (0 < (j = SA[i])) {\n            SA[i] = (c0 = T.get(--j));\n            if (c0 != c1) {\n                B.set(c1, b);\n                b = B.get(c1 = c0);\n            }\n            SA[--b] = ((0 < j) && (T.get(j - 1) > c1)) ? ~ ((int) T.get(j - 1)) : j;\n        } else if (j != 0) {\n            SA[i] = ~j;\n        } else {\n            pidx = i;\n        }\n    }\n    return pidx;\n}\n\n/* find the suffix array SA of T[0..n-1] in {0..k-1}^n\n use a working space (excluding T and SA) of at most 2n+O(1) for a constant alphabet */\nprivate static\nint\nSA_IS(BaseArray T, int[] SA, int fs, int n, int k, boolean isbwt) {\n    BaseArray C, B, RA;\n    int i, j, b, c, m, p, q, name, pidx = 0, newfs;\n    int c0, c1;\n    int flags = 0;\n\n    if (k <= 256) {\n        C = new IntArray(new int[k], 0);\n        if (k <= fs) {\n            B = new IntArray(SA, n + fs - k);\n            flags = 1;\n        } else {\n            B = new IntArray(new int[k], 0);\n            flags = 3;\n        }\n    } else if (k <= fs) {\n        C = new IntArray(SA, n + fs - k);\n        if (k <= (fs - k)) {\n            B = new IntArray(SA, n + fs - k * 2);\n            flags = 0;\n        } else if (k <= 1024) {\n            B = new IntArray(new int[k], 0);\n            flags = 2;\n        } else {\n            B = C;\n            flags = 8;\n        }\n    } else {\n        C = B = new IntArray(new int[k], 0);\n        flags = 4 | 8;\n    }\n\n    /* stage 1: reduce the problem by at least 1/2\n   sort all the LMS-substrings */\n    getCounts(T, C, n, k);\n    getBuckets(C, B, k, true); /* find ends of buckets */\n    for (i = 0; i < n; ++i) {\n        SA[i] = 0;\n    }\n    b = -1;\n    i = n - 1;\n    j = n;\n    m = 0;\n    c0 = T.get(n - 1);\n    do {\n        c1 = c0;\n    } while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n    for (; 0 <= i;) {\n        do {\n            c1 = c0;\n        } while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n        if (0 <= i) {\n            if (0 <= b) {\n                SA[b] = j;\n            }\n            b = B.update(c1, -1);\n            j = i;\n            ++m;\n            do {\n                c1 = c0;\n            } while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n        }\n    }\n    if (1 < m) {\n        LMSsort(T, SA, C, B, n, k);\n        name = LMSpostproc(T, SA, n, m);\n    } else if (m == 1) {\n        SA[b] = j + 1;\n        name = 1;\n    } else {\n        name = 0;\n    }\n\n    /* stage 2: solve the reduced problem\n   recurse if names are not yet unique */\n    if (name < m) {\n        if ((flags & 4) != 0) {\n            C = null;\n            B = null;\n        }\n        if ((flags & 2) != 0) {\n            B = null;\n        }\n        newfs = (n + fs) - (m * 2);\n        if ((flags & (1 | 4 | 8)) == 0) {\n            if ((k + name) <= newfs) {\n                newfs -= k;\n            } else {\n                flags |= 8;\n            }\n        }\n        for (i = m + (n >> 1) - 1, j = m * 2 + newfs - 1; m <= i; --i) {\n            if (SA[i] != 0) {\n                SA[j--] = SA[i] - 1;\n            }\n        }\n        RA = new IntArray(SA, m + newfs);\n        SA_IS(RA, SA, newfs, m, name, false);\n        RA = null;\n\n        i = n - 1;\n        j = m * 2 - 1;\n        c0 = T.get(n - 1);\n        do {\n            c1 = c0;\n        } while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n        for (; 0 <= i;) {\n            do {\n                c1 = c0;\n            } while ((0 <= --i) && ((c0 = T.get(i)) <= c1));\n            if (0 <= i) {\n                SA[j--] = i + 1;\n                do {\n                    c1 = c0;\n                } while ((0 <= --i) && ((c0 = T.get(i)) >= c1));\n            }\n        }\n\n        for (i = 0; i < m; ++i) {\n            SA[i] = SA[m + SA[i]];\n        }\n        if ((flags & 4) != 0) {\n            C = B = new IntArray(new int[k], 0);\n        }\n        if ((flags & 2) != 0) {\n            B = new IntArray(new int[k], 0);\n        }\n    }\n\n    /* stage 3: induce the result for the original problem */\n    if ((flags & 8) != 0) {\n        getCounts(T, C, n, k);\n    }\n    /* put all left-most S characters into their buckets */\n    if (1 < m) {\n        getBuckets(C, B, k, true); /* find ends of buckets */\n        i = m - 1;\n        j = n;\n        p = SA[m - 1];\n        c1 = T.get(p);\n        do {\n            q = B.get(c0 = c1);\n            while (q < j) {\n                SA[--j] = 0;\n            }\n            do {\n                SA[--j] = p;\n                if (--i < 0) {\n                    break;\n                }\n                p = SA[i];\n            } while ((c1 = T.get(p)) == c0);\n        } while (0 <= i);\n        while (0 < j) {\n            SA[--j] = 0;\n        }\n    }\n    if (isbwt == false) {\n        induceSA(T, SA, C, B, n, k);\n    } else {\n        pidx = computeBWT(T, SA, C, B, n, k);\n    }\n    C = null;\n    B = null;\n    return pidx;\n}\n\n/** Suffixsorting **/\n/* byte */\npublic static\nint\nsuffixsort(byte[] T, int[] SA, int n) {\n    if ((T == null) || (SA == null) || (T.length < n) || (SA.length < n)) {\n        return -1;\n    }\n    if (n <= 1) {\n        if (n == 1) {\n            SA[0] = 0;\n        }\n        return 0;\n    }\n    return SA_IS(new ByteArray(T, 0), SA, 0, n, 256, false);\n}\n/* char */\npublic static\nint\nsuffixsort(char[] T, int[] SA, int n) {\n    if ((T == null) || (SA == null) || (T.length < n) || (SA.length < n)) {\n        return -1;\n \n\n\n\n\n\n\n    }\n    if (n <= 1) {\n        if (n == 1) {\n            SA[0] = 0;\n        }\n        return 0;\n    }\n    return SA_IS(new CharArray(T, 0), SA, 0, n, 65536, false);\n}\n/* short */\npublic static\nint\nsuffixsort(short[] T, int[] SA, int n, int k) {\n    if ((T == null) || (SA == null) || (T.length < n) || (SA.length < n) || (k <= 0) || (65536 < k)) {\n        return -1;\n    }\n    if (n <= 1) {\n        if (n == 1) {\n            SA[0] = 0;\n        }\n        return 0;\n    }\n    return SA_IS(new ShortArray(T, 0), SA, 0, n, k, false);\n}\n/* int */\npublic static\nint\nsuffixsort(int[] T, int[] SA, int n, int k) {\n    if ((T == null) || (SA == null) || (T.length < n) || (SA.length < n) || (k <= 0)) {\n        return -1;\n    }\n    if (n <= 1) {\n        if (n == 1) {\n            SA[0] = 0;\n        }\n        return 0;\n    }\n    return SA_IS(new IntArray(T, 0), SA, 0, n, k, false);\n}\n/* String */\npublic static\nint\nsuffixsort(String T, int[] SA, int n) {\n    if ((T == null) || (SA == null) || (T.length() < n) || (SA.length < n)) {\n        return -1;\n    }\n    if (n <= 1) {\n        if (n == 1) {\n            SA[0] = 0;\n        }\n        return 0;\n    }\n    return SA_IS(new StringArray(T, 0), SA, 0, n, 65536, false);\n}\n\n/** Burrows-Wheeler Transform **/\n/* byte */\npublic static\nint\nbwtransform(byte[] T, byte[] U, int[] A, int n) {\n    int i, pidx;\n    if ((T == null) || (U == null) || (A == null) || (T.length < n) || (U.length < n) || (A.length < n)) {\n        return -1;\n    }\n    if (n <= 1) {\n        if (n == 1) {\n            U[0] = T[0];\n        }\n        return n;\n    }\n    pidx = SA_IS(new ByteArray(T, 0), A, 0, n, 256, true);\n    U[0] = T[n - 1];\n    for (i = 0; i < pidx; ++i) {\n        U[i + 1] = (byte)(A[i] & 0xff);\n    }\n    for (i += 1; i < n; ++i) {\n        U[i] = (byte)(A[i] & 0xff);\n    }\n    return pidx + 1;\n}\n/* char */\npublic static\nint\nbwtransform(char[] T, char[] U, int[] A, int n) {\n    int i, pidx;\n    if ((T == null) || (U == null) || (A == null) || (T.length < n) || (U.length < n) || (A.length < n)) {\n        return -1;\n    }\n    if (n <= 1) {\n        if (n == 1) {\n            U[0] = T[0];\n        }\n        return n;\n    }\n    pidx = SA_IS(new CharArray(T, 0), A, 0, n, 65536, true);\n    U[0] = T[n - 1];\n    for (i = 0; i < pidx; ++i) {\n        U[i + 1] = (char)(A[i] & 0xffff);\n    }\n    for (i += 1; i < n; ++i) {\n        U[i] = (char)(A[i] & 0xffff);\n    }\n    return pidx + 1;\n}\n/* short */\npublic static\nint\nbwtransform(short[] T, short[] U, int[] A, int n, int k) {\n    int i, pidx;\n    if ((T == null) || (U == null) || (A == null) || (T.length < n) || (U.length < n) || (A.length < n) || (k <= 0) || (65536 < k)) {\n        return -1;\n    }\n    if (n <= 1) {\n        if (n == 1) {\n            U[0] = T[0];\n        }\n        return n;\n    }\n    pidx = SA_IS(new ShortArray(T, 0), A, 0, n, k, true);\n    U[0] = T[n - 1];\n    for (i = 0; i < pidx; ++i) {\n        U[i + 1] = (short)(A[i] & 0xffff);\n    }\n    for (i += 1; i < n; ++i) {\n        U[i] = (short)(A[i] & 0xffff);\n    }\n    return pidx + 1;\n}\n/* int */\npublic static\nint\nbwtransform(int[] T, int[] U, int[] A, int n, int k) {\n    int i, pidx;\n    if ((T == null) || (U == null) || (A == null) || (T.length < n) || (U.length < n) || (A.length < n) || (k <= 0)) {\n        return -1;\n    }\n    if (n <= 1) {\n        if (n == 1) {\n            U[0] = T[0];\n        }\n        return n;\n    }\n    pidx = SA_IS(new IntArray(T, 0), A, 0, n, k, true);\n    U[0] = T[n - 1];\n    for (i = 0; i < pidx; ++i) {\n        U[i + 1] = A[i];\n    }\n    for (i += 1; i < n; ++i) {\n        U[i] = A[i];\n    }\n    return pidx + 1;\n}\n}",
			"file": "/C/Users/karbarcca/code/sais-java/sais-java/sais.java",
			"file_size": 20507,
			"file_write_time": 130415281919508895,
			"settings":
			{
				"buffer_size": 18391,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/Users/karbarcca/code/sais-java/sais-java/suftest.java",
			"settings":
			{
				"buffer_size": 4500,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 288.0,
		"selected_items":
		[
			[
				"open",
				"Sublime-IJulia: Open New IJulia Console"
			],
			[
				"ope",
				"SublimeREPL: SBT for opened folder"
			],
			[
				"iju",
				"IJulia: Set as working dir"
			],
			[
				"opeN",
				"Sublime-IJulia: Open New IJulia Console"
			],
			[
				"ijuli",
				"IJulia: Set as working dir"
			],
			[
				"ijul",
				"IJulia: Set as working dir"
			],
			[
				"OPEN",
				"Sublime-IJulia: Open New IJulia Console"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"git",
				"Git: Status"
			],
			[
				"openn",
				"Sublime-IJulia: Open New IJulia Console"
			],
			[
				"juli",
				"IJulia: Set as working dir"
			],
			[
				"checkou",
				"Git: Checkout"
			],
			[
				"checko",
				"Git: Checkout"
			],
			[
				"git push",
				"Git: Push Current Branch"
			],
			[
				"check",
				"Git: Checkout New Branch"
			],
			[
				"git status",
				"Git: Status"
			],
			[
				"gitstatu",
				"Git: Status"
			],
			[
				"isntall",
				"Package Control: Install Package"
			],
			[
				"markdo",
				"Markdown Preview: Open Markdown Cheat sheet"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"opwn",
				"Sublime-Julia: Open New REPL"
			],
			[
				"op",
				"Sublime-Julia: Open New REPL"
			],
			[
				"OPE",
				"Sublime-Julia: Open New REPL"
			],
			[
				"eval",
				"Sublime-Julia: Evaluate Line"
			],
			[
				"eva",
				"Sublime-Julia: Evaluate Line"
			],
			[
				"evaul",
				"Sublime-Julia: Evaluate Line"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"remo",
				"Package Control: Remove Package"
			],
			[
				"in",
				"Package Control: Install Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"disabl",
				"SublimeLinter: Disable Linting"
			],
			[
				"Snippet: ",
				"Snippet: Lorem ipsum"
			],
			[
				"fetch",
				"Fetch: File"
			]
		],
		"width": 474.0
	},
	"console":
	{
		"height": 163.0,
		"history":
		[
			"import IPython",
			"import zmq",
			"locale.getpreferredencoding()",
			"import locale",
			"x",
			"x = 1",
			"'\\u03bc'.encode('utf8')",
			"view.encoding()",
			"view.run_command(\"left_delete\")",
			"view.run_command(\"remove\")",
			"t.name()",
			"t = window.active_view()",
			"t.settings().get(\"julia_id\")",
			"t = window.active_view()",
			"t.settings().get(\"julia_id\")",
			"t.julia_id()",
			"t.julia_id",
			"t.name()",
			"t",
			"t = window.active_view()",
			"view.julia_id",
			"view.id",
			"view.id()",
			"window.new_file()",
			"window.set_view_index(t,2,10)",
			"window.set_view_index(t,2,0)",
			"window.set_view_index(t,0,0)",
			"window.set_view_index(t,1,0)",
			"window.set_view_index(t,2,0)",
			"window.num_groups()",
			"window.get_view_index(t)",
			"len(window.views_in_group(2))",
			"len(window.views_in_group(1))",
			"len(window.views_in_group(0))",
			"window.views_in_group(0)",
			"t = window.active_view()",
			"len(window.views_in_group(0))",
			"len(window.views_in_group(4))",
			"len(window.views_in_group(3))",
			"len(window.views_in_group(2))",
			"len(window.views_in_group(1))",
			"window.views_in_group(1)",
			"window.set_view_index(view,2,0)",
			"window.set_view_index(4,2,0)",
			"window.num_groups()",
			"window.run_command('julia_open')",
			"view.run_command('julia_view_previous')",
			"window.run_command('julia_open')",
			"view.run_command('julia_view_previous')",
			"window.run_command('julia_open')",
			"view.run_command('view_previous')",
			"window.run_command('julia_open')",
			"view.run_command('view_previous')",
			"window.run_command('julia_open')",
			"view.run_command('view_previous')",
			"window.run_command('julia_open')",
			"view.run_command('view_previous')",
			"view.run_command('previous_command')",
			"view.run_command('view_previous')",
			"window.run_command('julia_open')",
			"false",
			"window.run_command('julia_open')",
			"hey",
			"window.run_command('julia_open')",
			"hey",
			"window.run_command('julia_open')",
			"hey",
			"window.run_command('julia_open')",
			"hey",
			"window.run_command('julia_open')",
			"hey",
			"window.run_command('julia_open')",
			"false",
			"window.run_command('julia_open')",
			"window.run_command('julia_test')",
			"window.run_command('julia_open')",
			"hey",
			"window.run_command('julia_open')",
			"window.run_command('julia_test')",
			"hey",
			"window.run_command('julia_test')",
			"window.run_command('julia_open')",
			"window.run_command('julia_test')",
			"t = window.run_command('julia_test')",
			"print(t)",
			"t = window.run_command('julia_test')",
			"window.run_command('julia_open')",
			"print(t)",
			"t",
			"t = window.run_command('julia_test')",
			"window.run_command('julia_test')",
			"hey",
			"window.run_command('julia_open')",
			"hey",
			"window.run_command('julia_open')",
			"hey",
			"window.run_command('julia_open')",
			"window.run_command('julia_test')",
			"window.run_command('julia_open')",
			"window.run_command('julia_test')",
			"view.run_command('julia_test')",
			"view.run_command('julia_enter')",
			"window.run_command('julia_open')",
			"hey",
			"window.run_command('julia_enter')",
			"window.run_command('julia_open')",
			"cmds[\"windows\"]",
			"cmds[1]",
			"cmds",
			"cmds = se.get('julia_command')",
			"print(se)",
			"se",
			"se = sublime.load_settings('Sublime-Julia.sublime-settings')",
			"import sublime",
			"os.name",
			"os.sys",
			"os",
			"os.name",
			"import os",
			"window.run_command('julia_open')",
			"view.run_command('julia_open')",
			"view.RunCommand('julia_open')",
			"view.runCommand('julia_open')",
			"import sublimejulia",
			"import sublimerepljulia",
			"sublimerepljulia",
			"manager",
			"repl"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/C/Users/karbarcca/AppData/Local/Temp/Temp1_sais-2.4.1.zip/sais-2.4.1/lib/sais_n.i",
		"/C/Users/karbarcca/AppData/Local/Temp/Temp1_sais-2.4.1.zip/sais-2.4.1/lib/sais64.c",
		"/C/Users/karbarcca/AppData/Local/Temp/Temp1_sais-2.4.1.zip/sais-2.4.1/include/sais64.h.in",
		"/C/Users/karbarcca/AppData/Local/Temp/Temp1_sais-2.4.1.zip/sais-2.4.1/lib/sais.c",
		"/C/Users/karbarcca/code/sais-java/sais-java/build.xml",
		"/C/Users/karbarcca/code/sais-java/sais-java/bwtest.java",
		"/C/Users/karbarcca/code/sais-java/sais-java/COPYING",
		"/C/Users/karbarcca/code/sais-java/sais-java/is_orig.c",
		"/C/Users/karbarcca/code/sais-java/sais-java/sais.java",
		"/C/Users/karbarcca/code/sais-lite-2.4.1/sais-lite-2.4.1/sais.c",
		"/C/Users/karbarcca/code/sais-lite-2.4.1/sais-lite-2.4.1/sais.h",
		"/C/Users/karbarcca/METADATA.jl/Dates/url",
		"/C/Users/karbarcca/METADATA.jl/Dates/versions/0.0.2/requires",
		"/C/Users/karbarcca/METADATA.jl/Dates/versions/0.0.2/sha1",
		"/C/Users/karbarcca/METADATA.jl/Dates/versions/0.0.1/requires",
		"/C/Users/karbarcca/METADATA.jl/Dates/versions/0.0.0/requires",
		"/C/Users/karbarcca/METADATA.jl/Dates/versions/0.1.6/requires",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/conversions.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/test_ranges.jl",
		"/C/Users/karbarcca/code/codeanalysis/analysis.jl",
		"/C/Users/karbarcca/code/append try catch.jl",
		"/C/Users/karbarcca/julia/base/REPLCompletions.jl",
		"/C/Users/karbarcca/julia/base/array.jl",
		"/C/Users/karbarcca/julia/base/pkg/entry.jl",
		"/C/Users/karbarcca/julia/test/pkg.jl",
		"/C/Users/karbarcca/julia/test/replcompletions.jl",
		"/C/Users/karbarcca/julia/test/arrayops.jl",
		"/C/Users/karbarcca/julia/base/hashing2.jl",
		"/C/Users/karbarcca/julia/base/constants.jl",
		"/C/Users/karbarcca/julia/base/printf.jl",
		"/C/Users/karbarcca/julia/base/quadgk.jl",
		"/C/Users/karbarcca/julia/base/osutils.jl",
		"/C/Users/karbarcca/julia/base/libutils.jl",
		"/C/Users/karbarcca/julia/base/test.jl",
		"/C/Users/karbarcca/julia/base/sysimg.jl",
		"/C/Users/karbarcca/julia/base/reflection.jl",
		"/C/Users/karbarcca/code/Meetup.jl",
		"/C/Users/karbarcca/code/dates/base_Dates.jl",
		"/C/Users/karbarcca/code/dates/dates.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/docs/docs.md",
		"/C/Users/karbarcca/julia/doc/manual/integers-and-floating-point-numbers.rst",
		"/C/Users/karbarcca/julia/doc/stdlib/pkg.rst",
		"/C/Users/karbarcca/julia/doc/stdlib/base.rst",
		"/C/Users/karbarcca/julia/doc/stdlib/profile.rst",
		"/C/Users/karbarcca/julia/test/broadcast.jl",
		"/C/Users/karbarcca/julia/test/bitarray.jl",
		"/C/Users/karbarcca/Downloads/integer_times_test.jl",
		"/C/Users/karbarcca/Downloads/integer_times.jl",
		"/C/Users/karbarcca/julia/base/c.jl",
		"/C/Users/karbarcca/julia/base/math.jl",
		"/C/Users/karbarcca/julia/base/libc.jl",
		"/C/Users/karbarcca/julia/base/base.jl",
		"/C/Users/karbarcca/julia/base/exports.jl",
		"/C/Users/karbarcca/julia/base/build_h.jl",
		"/C/Users/karbarcca/julia/base/sysinfo.jl",
		"/C/Users/karbarcca/julia/base/stream.jl",
		"/C/Users/karbarcca/julia/doc/stdlib/sort.rst",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/test_conversions.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/test_periods.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/test_types.jl",
		"/C/Users/karbarcca/code/dates/sysimg.jl",
		"/C/Users/karbarcca/code/dates/runtests.jl",
		"/C/Users/karbarcca/code/dates/exports.jl",
		"/C/Users/karbarcca/code/dates_transfer.jl",
		"/C/Users/karbarcca/julia/test/dates/accessors.jl",
		"/C/Users/karbarcca/julia/test/runtests.jl",
		"/C/Users/karbarcca/.julia/v0.3/DateExtensions/src/DateExtensions.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/test_query.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/test_adjusters.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/test_io.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/.travis.yml",
		"/C/Users/karbarcca/.julia/v0.3/DateExtensions/src/extensions.jl",
		"/C/Users/karbarcca/julia/base/range.jl",
		"/C/Users/karbarcca/julia/base/set.jl",
		"/C/Users/karbarcca/julia/base/mmap.jl",
		"/C/Users/karbarcca/julia/base/pointer.jl",
		"/C/Users/karbarcca/julia/base/serialize.jl",
		"/C/Users/karbarcca/julia/test/repl.jl",
		"/C/Users/karbarcca/.julia/v0.3/TimeZones/deps/build.jl",
		"/C/Users/karbarcca/.julia/v0.3/Timezones/src/tzcompile.jl",
		"/C/Users/karbarcca/julia/base/operators.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/perf/perf.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/io.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/adjusters.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/ranges.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/conversions.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/test_arithmetic.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/arithmetic.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/query.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/test_accessors.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/accessors.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/periods.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/types.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/src/Dates.jl",
		"/C/Users/karbarcca/julia/contrib/windows/juliarc.jl",
		"/C/Users/karbarcca/julia/base/interactiveutil.jl",
		"/C/Users/karbarcca/code/hello.c",
		"/C/Users/karbarcca/.julia/v0.3/LibGit2/vendor/libgit2/Makefile.embed",
		"/C/Users/karbarcca/.julia/v0.3/LibGit2/src/api.jl",
		"/C/Users/karbarcca/.julia/v0.3/LibGit2/src/LibGit2.jl",
		"/C/Users/karbarcca/ghost/ghost.jl",
		"/C/Users/karbarcca/AppData/Local/LightTable/plugins/Bracket_glow/bracketglow.behaviors",
		"/C/Users/karbarcca/AppData/Local/LightTable/plugins/Bracket_glow/bracketglow.css",
		"/C/Users/karbarcca/AppData/Local/LightTable/plugins/Bracket_glow/plugin.edn",
		"/C/Users/karbarcca/AppData/Local/LightTable/plugins/Opener/opener.behaviors",
		"/C/Users/karbarcca/AppData/Local/LightTable/plugins/Opener/src/lt/plugins/opener.cljs",
		"/C/Users/karbarcca/AppData/Local/LightTable/plugins/Opener/History.md",
		"/C/Users/karbarcca/AppData/Local/LightTable/plugins/Opener/project.clj",
		"/C/Users/karbarcca/AppData/Local/LightTable/plugins/Opener/opener_compiled.js",
		"/C/Users/karbarcca/ghost/static/index.html",
		"/C/Users/karbarcca/ghost/static/robots.txt",
		"/C/Users/karbarcca/ghost/content/themes/MinimalisticBlogTheme/Minimalistic Blog Theme/tag.hbs",
		"/C/Users/karbarcca/ghost/content/themes/MinimalisticBlogTheme/Minimalistic Blog Theme/post.hbs",
		"/C/Users/karbarcca/ghost/content/themes/casper/index.hbs",
		"/C/Users/karbarcca/ghost/content/themes/casper/default.hbs",
		"/C/Users/karbarcca/ghost/content/themes/casper/README.md",
		"/C/Users/karbarcca/ghost/content/themes/MinimalisticBlogTheme/Minimalistic Blog Theme/assets/config.rb",
		"/C/Users/karbarcca/ghost/content/themes/MinimalisticBlogTheme/Minimalistic Blog Theme/partials/pagination.hbs",
		"/C/Users/karbarcca/ghost/content/themes/MinimalisticBlogTheme/Minimalistic Blog Theme/default.hbs",
		"/C/Users/karbarcca/ghost/content/themes/MinimalisticBlogTheme/Minimalistic Blog Theme/index.hbs",
		"/C/Users/karbarcca/ghost/content/themes/MinimalisticBlogTheme/Minimalistic Blog Theme/package.json",
		"/C/Users/karbarcca/nanomsg/configure.ac",
		"/C/Users/karbarcca/julia/base/Dates.jl",
		"/C/Users/karbarcca/julia/test/dates.jl",
		"/C/Users/karbarcca/julia/test/dates/conversions.jl",
		"/C/Users/karbarcca/.julia/v0.3/Dates/test/runtests.jl",
		"/C/Users/karbarcca/julia/Makefile",
		"/C/Users/karbarcca/julia/deps/Makefile"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
			"C:\\Users\\karbarcca\\.julia\\v0.3\\Dates\\src",
			"C:\\Users\\karbarcca\\julia\\base\\pkg",
			"C:\\Users\\karbarcca\\julia\\base",
			"C:\\Users\\karbarcca\\julia\\test",
			"C:\\Users\\karbarcca\\julia\\base",
			"C:\\Users\\karbarcca\\nanomsg",
			"C:\\Users\\karbarcca\\julia\\base\\",
			"C:\\Users\\karbarcca\\julia\\base\\pkg",
			"C:\\Users\\karbarcca\\julia\\base\\",
			"C:\\Users\\karbarcca\\julia\\base\\pkg",
			"C:\\Users\\karbarcca\\julia\\",
			"C:\\Users\\karbarcca\\julia\\base",
			"C:\\Users\\karbarcca\\.julia\\v0.3",
			"C:\\Users\\karbarcca\\METADATA.jl",
			"C:\\Users\\karbarcca\\julia\\base",
			"C:\\Users\\karbarcca\\julia",
			"C:\\Users\\karbarcca\\.julia",
			"C:\\Users\\karbarcca\\julia\\base",
			"C:\\Users\\karbarcca\\julia\\",
			"C:\\Users\\karbarcca\\julia\\test",
			"C:\\Users\\karbarcca\\julia\\base",
			"C:\\Users\\karbarcca\\Downloads\\tzdata2013h",
			"C:\\Users\\karbarcca\\julia\\base",
			"C:\\Users\\karbarcca\\.julia\\Gadfly",
			"C:\\Users\\karbarcca\\AppData\\Roaming\\Sublime Text 3\\Packages\\SublimeREPL",
			"C:\\Users\\karbarcca\\julia\\base",
			"/base"
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"Byte",
			"SA_IS",
			"Date(",
			"dayofweek",
			"    &&",
			" Mon ",
			"Mon",
			"dayofweek(",
			"dayofweek",
			" month",
			"month",
			"year(",
			"year",
			"yearmonthday",
			"::TimeType",
			"Dates.",
			"MONTHDAYS2",
			"MONTHDAYS",
			"append!",
			"utf8",
			"filter",
			"utf8",
			"append",
			"T[]",
			"InexactError",
			"@BIGFLOAT",
			"eu",
			"pi",
			"BigFloat",
			"old",
			"length(A) == 2",
			"Base.",
			"array",
			"old",
			"_growat",
			"_deleteat",
			"function",
			"splice",
			"Base.",
			"1",
			"splice",
			"_growat",
			"BigFloat",
			"splice",
			"append!",
			"item",
			"splice",
			"_deleteat",
			"date\\b",
			"\\n",
			"dates",
			"\"",
			"``Integer`` value.",
			"Period type",
			"::Integer",
			"first",
			"adjusting",
			"month",
			"week",
			"the Date or DateTime",
			"of the Date",
			"Date or DateTime",
			"TimeType",
			"DateDates",
			"millisecond",
			"second",
			"minute",
			"hour",
			"day",
			"week",
			"month",
			"year",
			"function::",
			"DateDates",
			"DateTime",
			"````",
			"`",
			"+00:00",
			"Z",
			"Z\"",
			"pointer\\(",
			"pointer",
			"Z\\\"",
			"first",
			"var",
			"Day",
			"Month",
			"+",
			"TTP",
			"poll.h",
			"host_os",
			"LIBTOOL",
			"Period",
			"=>",
			"Year",
			"dayofquarter",
			"quarterofyear",
			"Millisecond",
			"next",
			"start",
			"\\",
			"init",
			"\\",
			"bool",
			"bool\\('.'\\)",
			"set_remote_url",
			" FS",
			" FS ",
			"FS",
			"mv",
			"generate",
			"karbarcca",
			"json",
			"mv",
			"show",
			"Dates.",
			"isnewyears(x) || isindependenceday(x) ||\n       isveteransday(x) || ischristmas(x) ||\n       ismartinlutherking(x) || ispresidentsday(x) ||\n       ismemorialday(x) || islaborday(x) ||\n       iscolumbusday(x) || isthanksgiving(x)",
			"function ",
			"northside",
			"ROUNDING_MODE",
			"Base.Test.",
			"JULIA_EDITOR",
			"quinnj",
			"karbarcca",
			"`start ",
			"edit",
			"contains",
			"recorded"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"quinnj",
			"    ",
			"",
			" ",
			"",
			"()\n"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "sais.jl",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10621,
						"regions":
						{
						},
						"selection":
						[
							[
								2892,
								2892
							]
						],
						"settings":
						{
							"syntax": "Packages/IJulia/Syntax/Julia.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1080.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		},
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 1,
					"file": "/C/Users/karbarcca/code/sais-lite-2.4.1/sais-lite-2.4.1/sais.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16116,
						"regions":
						{
						},
						"selection":
						[
							[
								13004,
								13027
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5526.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/C/Users/karbarcca/code/sais-java/sais-java/sais.java",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18391,
						"regions":
						{
						},
						"selection":
						[
							[
								6325,
								6325
							]
						],
						"settings":
						{
							"syntax": "Packages/Java/Java.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4520.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/C/Users/karbarcca/code/sais-java/sais-java/suftest.java",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4500,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Java/Java.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 30.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.5,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 100.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.git-checkout":
	{
		"height": 100.0
	},
	"output.git-commit":
	{
		"height": 100.0
	},
	"output.git-push":
	{
		"height": 100.0
	},
	"project": "sais.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 392.0
	},
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 145.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
